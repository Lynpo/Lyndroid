# Java 内存模型与线程

### Java 内存模型（Java Memery Model， JMM）

目标：定义程序变量访问规则（此处变量与 Java 编程中所说的变量区别：此处包括实例字段、静态字段和构成数组对象的元素，
但不包括局部变量与方法参数，后者是线程私有的，不会被共享。

局部变量：如果局部变量是一个 reference 类型，他引用的对象在 Java 堆中可被各个线程共享，但 reference 本身在 Java 栈的局部变量表中，他是线程私有的。

对象拷贝副本：拷贝对象的引用、对象中某个线程访问到的字段存在拷贝（不是整个对象拷贝）。

##### 主内存与工作内存

![main memory and working memory](/image/javamemorymodel.jpg)
线程、主内存、工作内存三折的交互关系

类比下图
![processor-cache-memory](/image/processormainmemory.png)
处理器、高速缓存、主内存间的交互关系

##### 内存间交互操作

 8 种操作：原子的、不可在分的

* lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占的状态
* unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后变量才可以被其他线程锁定。
* read（读取）：作用于主内存变量，吧一个变量从主内存传输到线程的工作内存中，一边随后 load 动作使用
* load（载入）：作用于工作内存变量，把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。
* use（使用）：作用于工作内存变量，把工作内存中一个变量的值传递给执行引擎
* assign（赋值）：作用于工作内存变量，把一个从执行引擎接收到的值付给工作内存的变量
*  store（存储）：作用于工作内存变量，把工作内存中一个变量的值传动到主内存中，一边随后的 write 操作使用
* write（写入）：作用于主内存变量，把 store 操作从工作内存中得到的变量值放入主内存变量中。

 read-->load: should be executed in order(not mecessoryly continuously)

 store-->write should be executed in order(not mecessoryly continuously)

 （e.g.: read a, read b, load b, load a)

 其他规则：（部分略）

 * 不允许 read-load, store-write 操作之一单独出现：读了比载入，存储必写入
 * 工作内存中 assign 的变量必须同步回主内存
 * 不允许无原因地（没有 assgin 操作）把数据从工作内存同步回主内存中
 * 新变量只能在主内存中“诞生”，不允许工作内存中直接使用一个未被初始化（load或assign）的变量
 * 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线成执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。
 * 如果对变量执行 lock 操作，那将会清空工作内存中次变量的值，在执行引擎使用这个变量前，需要重新执行 load 和 assign 操作初始化变量的值。
 * 如果一个变量事先没有被 lock 操作锁定，那就不允许对他执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量。
 * 对一个变量执行 unlock 操作之前，必须先把次变量同步会主内存中（执行 store、write操作）。

##### 对于 volatile 型变量的特殊规则

当一个变量定义为 volatile 之后：

 * 保证此变量对所有线程可见性
  * 可见性：当一条线程修改了这个变量的值，新值对于其他线程来说可以立即得知
 * 禁止指令重排序优化

##### 对于 long 和 double 型变量的特殊规则
上述 8 种操作是原子性的，但是对于 64 位的数据类型（long 和 double），模型中定义了一条相对宽松的规则：

 * 允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、 store、read 和 write 这 4 个操作的原子性 —— 所谓的 long 和 double 的非原子协定。

 如果有多个线程共享一个未声明为 volatile 的 long 或 double 类型的变量，并同时对他们进行读取和修改操作，可能读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值 —— 这种情况非常罕见（商用 Java 虚拟机不会出现）

##### 原子性、可见性、有序性

 * 原子性： 8 种操作，synchronize 块之间的操作具备原子性
 * 可见性：一个线程修改，其他线程立即得知修改。

 除了 volatile 外，synchronize 和 final 也能实现可见性。

 synchronize 同步快的可见性实现：”对一个变量执行 unlock 之前，必须先把此变量同步回主内存中（执行 store、write 操作）”

 final 的可见性实现：被 final 修饰的字段在构造器中一旦初始化完成，并且构造器没有吧 “this” 的引用传递出去(this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那在其他线程中就能看见 final 字段的值。

 * 有序性：如果在本线程内观察，所有操作都是有序的；如果在一个线程观察另一个线程，所有操作都是无序的。

##### 现行发生原则

 * 程序次序规则：代码（顺序）控制流
 * 管程锁定规则： unlock 先于后面对同一个锁的 lock 操作
 * volatile 变量规则：一个变量的写操作先行发生于读操作
 * 线程启动规则：线程 start() 方法先于线程动作
 * 线程终止规则：线程操作先行与对该线程的终止检测（Thread.join()/Thread.isAlive() 可检测线程已经终止）
 * 线程中断规则：interrupt() 方法调用先行于被中断线程的代码检测到中断事件的发生（Thread.interrupted() 方法检测是否有中断发生）
 * 对象终结规则：对象初始化完成（构造方法执行结束）先行于它的 finalize() 方法的开始。
 * 传递性：操作 A 先行于操作 B， 操作 B 先行于操作 C，则操作 A 先行于操作 C

### Java 与线程
